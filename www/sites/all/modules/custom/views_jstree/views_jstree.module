<?php

module_load_include('inc', 'views_jstree', 'views_jstree.token');

/**
 * Implements of hook_views_api().
 */
function views_jstree_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'views_jstree'),
  );
}

/**
* Implements hook_menu
*/
function views_jstree_menu() {
  $items = array();
  $items['jstree/load/%/%'] = array(
    'page callback' => 'views_jstree_load_children',
    'page arguments' => array(2,3), //2=view, 3=parent_id
    'access callback' => 'views_jstree_load_children_access',
    'access arguments' => array(2,3),
  );
  
  $items['jstree/move/%/%'] = array(
    'page callback' => 'views_jstree_move_child',
    'page arguments' => array(2, 3), //2=view name, 3=the nid that is moved
    'access callback' => true,  //@TODO: user can alway move? Cannot? Shouldnot? only if he can edit the task!
  );

  return $items;
}

/**
* Implements hook_form_alter
*/
function views_jstree_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'views_exposed_form') {
    $form['#submit'][] = 'views_js_tree_views_exposed_form_submit';
  }
}

function views_js_tree_views_exposed_form_submit($form, $form_state) {
  //save the values submitted to the view if view is js tree plugin
  $_SESSION['views_jstree_filter'] = $_REQUEST;
  
}

function views_jstree_require_jstree() {
  //include the jstree with the library module
  $jstree_path = libraries_get_path('jstree');

  //if not exists, warn the user!
  $jstree_download = l('latest jstree', 'http://www.jstree.com');
  $jstree_root = $jstree_path;
  if (!file_exists($jstree_path."/jquery.jstree.js")) {
    drupal_set_message(t('Please download !jstree_download and place files from package in !jstree_root', array('!jstree_download' => $jstree_download, '!jstree_root' => $jstree_root)), 'warning');
  }
  
  //add jstree Javascript and all its components
  drupal_add_js($jstree_path."/_lib/jquery.cookie.js");
  drupal_add_js($jstree_path."/_lib/jquery.hotkeys.js");
  drupal_add_js($jstree_path."/jquery.jstree.js"); 
}

/**
 * Implements of hook_theme().
 */
function views_jstree_theme($existing, $type, $theme, $path) {
  return array(
    //the js tree
    'views_jstree' => array(
      'variables' => array(
        'view' => NULL,
        'options' => array(),
        'rows' => array(),
        'title' => NULL,
      ),
    ),
  );
}

/**
* Returns fields of a display. If fields are not overriden, we take the fields of the default view.
*/
function views_jstree_get_fields_of_view($view, $display) {
  $fields = false;
  if (isset($display->display_options['fields']))
    $fields = $display->display_options['fields'];

  if (!$fields) { //if not overriden, take from view
    if (isset($view->display['default']->display_options['fields']))
      $fields = $view->display['default']->display_options['fields'];
  }
  
  return $fields;
}

function views_jstree_get_options_of_view($view, $display) {
  $options = $display->display_options['style_options'];

  if (!$options) { //if not overriden, take from view
    $options = $view->display['default']->display_options['style_options'];
  }
  
  return $options;
}

/**
 * Theme function for the jstree style plugin.
 *
 * We need to do some weirdness that makes more sense as a theme function
 * than as a template.
 *
 * @ingroup themeable
 * @link http://drupal.org/node/355919
 */
function theme_views_jstree($variables) {
  //only if this is not a view path....oh man thats dirty :-(
  if (strpos($_GET['q'], 'jstree') === false)
    $_SESSION['view_jstree']['current_tree_url'] = $_GET['q'];  //so other modules know which url ist actually viewd (@see erpal_book_helper, erpal_book_helper_jstree_context_menu)
    
  views_jstree_require_jstree();
  //dpm($variables);
  $view = $variables['view'];
  $options = $variables['options'];
  $rows = $variables['rows'];
  $title = $variables['title'];

  $result = $view->result;
  $fields = &$view->field;

  $parents = array();

  if (! $fields[$options['id_field']] instanceof views_handler_field) {
    drupal_set_message(t('ID field is invalid: %field', array('%field' => $options['id_field'])), 'error');
    return '';
  }

  if (! $fields[$options['parent_field']] instanceof views_handler_field) {
    drupal_set_message(t('Parent field is invalid: %field', array('%field' => $options['parent_field'])), 'error');
    return '';
  }
  
  //now we show the first nodes at top level here, other nodes are reloaded by ajax in the tree  
  $nid = $view->args[0];
  $id = 'views_jstree_'.$nid;
  $view_name = $view->name;
  //add javascript variables
  $ajax_url = url("jstree/load/$view_name");
  $ajax_url_move = url("jstree/move/$view_name");
  
  $jstree_options = array();
  $jstree_options['trees'][$id] = array('parent_nid' => $nid, 'ajax_url' => $ajax_url, 'ajax_url_move' => $ajax_url_move);
  
  //get all parent possible parent child node type relations. 
  $allowed_parent_child_types = module_invoke_all('jstree_allowed_child_types');
  if (!$allowed_parent_child_types)
    $allowed_parent_child_types = array();
  $jstree_options['allowed_parent_child_types'] = $allowed_parent_child_types;
  drupal_add_js(array('jstree_options' => $jstree_options), 'setting');
  
  $mod_path = drupal_get_path('module', 'views_jstree');
  drupal_add_js($mod_path."/js/views_jstree.js");
  
  //@TODO in eigene Templatefunktion!
  //@TODO größe so viel wie Platz ist! (100%)
  $width = 900;  
  $height = 600;
  return '<div id="'.$id.'" class="jstree" style="height:'.$height.'px; width:'.$width.'px !important;"></div>';
 
}

/**
* Access callback for ajax loading of view_data
*/
function views_jstree_load_children_access() {
  return true; //@TODO implement access validation, maybe use permissions set on view!
}

/**
* AJAX Callback function for moving the node in jstree
* @param $nid the nid of the node that is moved
*/
function views_jstree_move_child($view_name, $nid) {
  $data = $_REQUEST;
  
  $op = $data['operation'];
  $new_parent_nid = $data['new_parent_nid'];
  $position = $data['position'];
  $root = $data['root'];
  
  $view = views_get_view($view_name);
  if (!is_object($view))
    die(json_encode(array('result' => false)));
    
  $children_display = _views_jstree_get_children_display($view);  //the view that displays the children
  
  if ($op != 'move_node')
    die(json_encode(array('result' => false)));
   
  $node = node_load($nid);
  //check what is the parent field
  $fields = views_jstree_get_fields_of_view($view, $children_display);
  $options = views_jstree_get_options_of_view($view, $children_display);
  
  $parent_field = $fields[$options['parent_field']];
  $weight_field = $fields[$options['weight_field']];

  if ($new_parent_nid == 1){  //@TODO: is this really allways 1 if we drag at top level under the root??
    //set parent to argument, because this is the root.
    $new_parent_nid = $root;
  }

  $node->{$parent_field['id']}[LANGUAGE_NONE][0]['target_id'] = $new_parent_nid;
  $node->{$weight_field['id']}[LANGUAGE_NONE][0]['value'] = $position;

  //call hook when node is moved, so other module could interact with the moved node
  module_invoke_all('views_tree_before_move', $node, $position);

  node_save($node);

  module_invoke_all('views_tree_after_move', $node);

  die(json_encode(array('result' => true)));
}


/**
* AJAX Callback function for loading tree children
*/
function views_jstree_load_children($view_name, $parent_id) {

  $view = views_get_view($view_name);
  if (!is_object($view))
    return array();
  
  $parent_node = node_load($parent_id);
  $parent_types = array($parent_node->type);

  $children_display = _views_jstree_get_children_display($view, $parent_types);

  //execute it and return data as json  
  $args = array($parent_id);
  
  $filter = $_SESSION['views_jstree_filter']; //@TODO this works but it is not the best way to do that!
  if ($filter)
    $view->set_exposed_input($filter);
  
  $view->preview($children_display->id, $args);
  
  $result = $view->result;
  
  $fields = views_jstree_get_fields_of_view($view, $children_display);
  $options = views_jstree_get_options_of_view($view, $children_display);
  
  $parent_field = $fields[$options['parent_field']];
  $weight_field = $fields[$options['weight_field']];  
  $type_field = $fields[$options['type_field']];

  //output result as json to display in jstree
  $output = array();
  foreach($result as $delta=>$row) {        
    //Execute next view to see if it hase some children!
    $subargs = array($row->nid);
    $node_type = 'node_'.$type_field['id'];
    $row_type = $row->{$node_type};
    $parent_types = array($row_type);

    $view = views_get_view($view_name);
    $subview = _views_jstree_get_children_display($view, $parent_types);

    $view->preview($subview->id, $subargs);
   
    $hasChildren = $view->total_rows > 0;   
    
    $node_uri = url('node/'.$row->nid);
    //@TODO Views row style plugin? No hard coded row style format!
    //@TODO ensure in views UI that for this style plugin node_type is set as field as well as nid!

    $status = '';
    if (isset($row->field_field_task_status_term[0]['raw']['value']))  //@TODO should be dynamically set in view options for general usage
      $status = " ".$row->field_field_task_status_term[0]['raw']['value'];
      
    $output[] = array(
      "attr" => array("id" => "node_".$row->nid, "rel" => $row->node_type, "type" => $row->node_type, "uri" => $node_uri, 'entity_id' => $row->nid, 'class' => $row->node_type.$status), 
      "data" => $row->node_title,
      "state" => $hasChildren ? "closed" : '', //or '' if no Children!
      'context_menu' => _views_jstree_get_context_menu($view, $children_display, $row->node_type, $row->nid, $row, $parent_id),
    );
  }
  
  die(json_encode($output));
}

/**
* returns context_menu data for a given node
*/
function _views_jstree_get_context_menu($view, $display, $node_type, $nid, $row, $root_id) {
  //get the options first!
  $context_menu_options = $display->display_options['style_options']['context_menu'];
  if (!$context_menu_options) {
    //get options from default view
    $context_menu_options = $view->display['default']->display_options['style_options']['context_menu'];
  }

  //now get the menu either from textarea or from implemented hooks
  if ($context_menu_options['use_context_menu_hook']) {
    //from hooks!
    
    $menu = module_invoke_all('jstree_context_menu', 'node', $node_type, $nid, $root_id);
    return $menu;
  } else {
    $type_prefix = 'views_jstree';
    $type = $type_prefix."_".$view->name."_".$display->id;

    $custom_context_menu = $context_menu_options['custom_context_menu'];
    $custom_context_menu = token_replace($custom_context_menu, array($type => array('view' => $view, 'display' => $display, 'row' => $row)));
   
$br = "
";    //a linebreak that always works
    $menu = array();
    $items = explode($br, $custom_context_menu);
    foreach ($items as $item) {
      $elements = explode('|', $item);
      $title = $elements[0];
      $url = $elements[1];
      $menu[] = array('title' => $title, 'url' => $url);
    }
    
    return $menu;
  }
 
}

/**
* Return the view displaying the children using the ajax allback related to the given view
* @param a view which contains the display to get children
*/
function _views_jstree_get_children_display($view, $for_types=array()) {
  //@TODO make dynamic options in view to select the child view displaying ajax children
  $display_normal = false;
  $top_row_display = false;
  foreach($view->display as $display_id=>$display) {
    $display_options = $display->display_options;
    if (isset($display_options['style_options']['ajax_child_view'])) {
      if ($display_options['style_options']['ajax_child_view']) {
        //that ist the display!
        $display_normal = $display;
      }

      $ajax_child_view_top_types = $display_options['style_options']['ajax_child_view_top_types'];
      $types_intersection = array_intersect($for_types, $ajax_child_view_top_types);

      if (count($types_intersection)) {
        //that ist the display!
        $top_row_display = $display;
      }
    }
  }
  
  if (count($for_types) && $top_row_display) {
    return $top_row_display;
  }
  
  return $display_normal;
}

/**
 * Code mostly taken from views_tree module, THANKS!
 *
 * Normalize a value out of the record to an int.
 *
 * If the field in question comes from Field API, then it will be an array, not
 * an int.  We need to detect that and extract the int value we want from it.
 * Note that because Field API structures are so free-form, we have to specifically
 * support each field type.  For right now we support entityreference (target_id),
 * nodereference (nid), userreference (uid), and taxonomyreference (tid).
 *
 * @param mixed $value
 *   The value to normalize.  It should be either an int or an array. If an int,
 *   it is returned unaltered.  If it's an array, we extract the int we want
 *   and return that.
 * @param views_handler_field $field
 *   Metadata about the field we are extracting information from.
 * @return int
 *   The value of this key, normalized to an int.
 */
function views_jstree_normalize_key($value, views_handler_field $field) {
  if (is_array($value) && count($value)) {
    if (isset($field->field_info['columns'])) {
      $columns = array_keys($field->field_info['columns']);
      foreach ($columns as $column) {
        if (in_array($column, array('target_id', 'nid', 'uid', 'tid'))) {
          $field_property = $column;
          break;
        }
      }
    }
    else {
      $field_property = '';
    }
    return $field_property ? $value[0][$field_property] : 0;
  }
  else {
    return $value ? $value : 0;
  }
}
