<?php
/**
 *  @file commander/commander.module
 *  @author Thiemo Müller
 *  @version 1.0
 *  
 *  Define all public functions, hooks and globally available (i.e. reused) private functions
 */

define( 'MODULE_COMMANDER_UNNAMED_ARGUMENTS_INDEX', '' );

define( 'MODULE_COMMANDER_PERMISSION_ACCESS',           'access commander' );
define( 'MODULE_COMMANDER_PERMISSION_EXECUTE_ALL',      'execute all commander commands' );
define( 'MODULE_COMMANDER_PERMISSION_VIEW_GLOBAL_LOG',  'view global commander log entries' );

define( 'MODULE_COMMANDER_CLIENT_FILE',     'inc/client.inc' );
define( 'MODULE_COMMANDER_EXECUTION_FILE',  'inc/exec.inc' );

define( 'MODULE_COMMANDER_DEFAULT_CONSOLE_SHORTCUT', 'BACK_SLASH' );

define( 'MODULE_COMMANDER_COMMAND_HOOK',              'commander_command' );              // Return an array of all commands implemented by the module
define( 'MODULE_COMMANDER_COMMAND_ALTER_HOOK',        'commander_command_alter' );        // Alter the given commands (we use it to add custom aliases for example)
define( 'MODULE_COMMANDER_ARGUMENT_TYPE_HOOK',        'commander_argument_type' );        // Return an array of all argument types implemented by the module
define( 'MODULE_COMMANDER_ARGUMENT_TYPE_ALTER_HOOK',  'commander_argument_type_alter' );  // Alter the given types
define( 'MODULE_COMMANDER_ENVIRONMENT_HOOK',          'commander_environment' );          // Alter the environment-variable to add custom keys as required

define( 'MODULE_COMMANDER_VARIABLE_ALIASES',  'commander_aliases' );                      // A list of custom aliases
define( 'MODULE_COMMANDER_VARIABLE_MESSAGES', 'commander_messages' );                     // System messages

define( 'MODULE_COMMANDER_MESSAGES_SESSION_VARIABLE', 'commander-log' );

define( 'MODULE_COMMANDER_MAX_SUGGESTIONS',   5 );
define( 'MODULE_COMMANDER_MAX_MESSAGES',      50 );

define( 'COMMANDER_COMMAND_TYPE_UNNAMED_ARGUMENTS', 0x00 ); // The given arguments are unnamed, i.e. no <name>=<value> neither an -<name> <value>
define( 'COMMANDER_COMMAND_TYPE_SIGNED_ARGUMENTS',  0x01 ); // The given arguments are named as -<name> <value> or +<name> <value>
define( 'COMMANDER_COMMAND_TYPE_EQUAL_ARGUMENTS',   0x02 ); // The given arguments are named as <name>=<value>
define( 'COMMANDER_COMMAND_TYPE_DEFAULT',           COMMANDER_COMMAND_TYPE_SIGNED_ARGUMENTS );

/**
 *  Escape the given sequence
 *  
 *  @scope public
 *  @param value (string) The value to be used as an argument
 *  @param add_quotes (bool) Whether or not to prepend and append a double quote character
 *  @return (string) The escaped argument value
 */
function _commander_argument( $value, $add_quotes=TRUE ) {
  $value  = str_replace( array('\\','"'), array('\\\\','\\"'), $value );
  
  return $add_quotes ? '"' . $value . '"' : $value;
}

/**
 *  Check whether the given user has access to the given command
 *  
 *  @scope public
 *  @param user (user) The user to check against
 *  @param command (command) The command definition to check against
 *  @return (bool)
 */
function commander_check_user_command_access( $user, $command ) {
  
  if( !isset($command['access callback']) ) {
    
    if( !isset($command['access arguments']) || empty($command['access arguments']) )
      $access = user_access( MODULE_COMMANDER_PERMISSION_EXECUTE_ALL, $user );
    else
      $access = user_access( $command['access arguments'][0], $user );
    
  }
  else {
    
    if( $command['access callback']===TRUE || $command['access callback']===FALSE )
      $access = $command['access callback'];
    else
      $access = isset($command['access arguments']) && !empty($command['access arguments']) ? call_user_func_array( $command['access callback'], $command['access arguments'] ) : $command['access callback']();
    
  }
  
  return $access;
  
}

/**
 *  Get a list of all available commands, optionally filtered by user
 *  
 *  @scope public
 *  @param user (user) The user to filter by
 *  @return (array) A list of all commands as an associative array
 */
function commander_get_commands( $user=NULL ) {
  
  static $commands_cache  = NULL;
  if( !$commands_cache ) {
    
    $commands = array();
    $types    = commander_get_argument_types();
    
    foreach( module_implements( MODULE_COMMANDER_COMMAND_HOOK ) as $module ) {
      
      $function = $module . '_' . MODULE_COMMANDER_COMMAND_HOOK;
      $add      = $function();
      
      foreach( $add as $name=>$command ) {
        
        _commander_init_command( $types, $add, $name, $module );
        
      }
      
      $commands += $add;
      
    }
    
    $commands_cache = $commands;
    
  }
  
  foreach( module_implements( MODULE_COMMANDER_COMMAND_ALTER_HOOK ) as $module ) {
    
    $previous	= array_keys( $commands_cache );
    $function = $module . '_' . MODULE_COMMANDER_COMMAND_ALTER_HOOK;
    $function( $commands_cache );
    
    foreach( $commands_cache as $name=>$command )
      if( !in_array($name,$previous) )
        _commander_init_command( $types, $commands_cache, $name, $module );
    
  }
  
  if( !$user )
    return $commands_cache;
  
  // Perform access check
  $commands = $commands_cache;
  foreach( $commands as $name=>$command ) {
    
    if( !commander_check_user_command_access( $user, $command ) ) {
      $commands[ $name ]  = NULL;
      unset( $commands[ $name ] );
    }
    
  }
  
  return $commands;
  
}

/**
 *  Get a list of all available argument types
 *  
 *  @scope public
 *  @return (array) A list of all available argument types as an associative array
 */
function commander_get_argument_types() {
  
  static $types = NULL;
  if( $types )
    return $types;
  
  $types  = array();
  
  foreach( module_implements( MODULE_COMMANDER_ARGUMENT_TYPE_HOOK ) as $module ) {
    
    $function = $module . '_' . MODULE_COMMANDER_ARGUMENT_TYPE_HOOK;
    $add      = $function();
    
    foreach( $add as $name=>$type ) {
      $add[$name]['machine_name'] = $name;
      $add[$name]['module']       = $module;
      
      if( !isset($type['defaults']) )
        $add[$name]['defaults']     = array();
      
      $add[$name]['defaults']['value']  = '_commander_static_default_value';
      
      if( !isset($type['argc']) )
        $add[$name]['argc']         = -1;
    }
    
    $types  += $add;
    
  }
  
  foreach( module_implements( MODULE_COMMANDER_ARGUMENT_TYPE_ALTER_HOOK ) as $module ) {
    
    $function = $module . '_' . MODULE_COMMANDER_ARGUMENT_TYPE_ALTER_HOOK;
    $function( $types );
    
  }
  
  return $types;
  
}

/**
 *  Create the environment variable
 *  
 *  @scope public
 *  @param remote (boolean) Whether or not the command is executed from remote (AJAX request)
 *  @return (array) All current environmental variables
 */
function commander_get_environment( $remote ) {
  
  global $user;
  
  $environment  = array(
    'user'        => $user,
    'q'           => $remote ? $_SERVER['HTTP_REFERER'] : $_GET['q'],
    'timestamp'   => time(),
    'remote'      => $remote,
  );
  
  foreach( module_implements( MODULE_COMMANDER_ENVIRONMENT_HOOK ) as $module ) {
    
    $function = $module . '_' . MODULE_COMMANDER_ENVIRONMENT_HOOK;
    $function( $environment );
    
  }
  
  return $environment;
  
}

/**
 *  Get a list of all defaults of the given argument
 *  
 *  @scope public
 *  @param environment (array) The current environment
 *  @param command (array) The command definition
 *  @return (array) An associative array containing all default values for the given command
 */
function commander_get_command_defaults( $environment, $command ) {
  
  $defaults = array();
  $types    = commander_get_argument_types();
  
  if( isset($command['arguments']) ) {
    
    foreach( $command['arguments'] as $name=>$argument ) {
      
      $typename = $argument['type'];
      $type     = _commander_get_by_name_or_alias( $types, $typename );
      if( !isset($defaults[ $type['argc'] ]) )
        $defaults[ $type['argc'] ]  = array();
      
      $extend   = &$defaults[ $type['argc'] ];
      
      $extend[ $name ]  = array();
      if( isset($argument['default']) ) {
        
        if( isset($type['defaults'][ $argument['default'] ]) ) {
          
          if( isset($type['file']) )
            module_load_include( '', $type['module'], $type['file'] );
          
          $extend[ $name ]  = $type['defaults'][ $argument['default'] ]( $environment, $argument );
          if( !is_array($extend[ $name ]) )
            $extend[ $name ]	= array( $extend[ $name ] );
          
        }
        
      }
      
      if( isset($argument['alias']) )
        $extend[ $argument['alias'] ] = $extend[ $name ];
      
    }
    
  }
  
  if( isset($command['defaults']) ) {
    if( isset($command['file'] ) )
      module_load_include( '', $command['module'], $command['file'] );
    
    $command['defaults']( $defaults );
  }
  
  return $defaults;
  
}

/**
 *  Get the name of the command to be executed
 *  
 *  @scope public
 *  @param input (string) The input to extract the command name from
 *  @return (string) The name of the command
 */
function commander_get_command_name( $input ) {
  $pos  = strpos( $input, ' ' );
  return $pos===FALSE ? $input : substr($input,0,$pos);
}

/**
 *  Add a message to be displayed in the console
 *  
 *  @scope public
 *  @param message (array) An array giving 'source' (like 'system' or 'user-message'), 'type' (like 'notice', 'warning', 'error'. See watchdog. Defaults to 'notice') and 'message', all as strings. Optional 'timestamp'.
 *  @param global (boolean) Whether or not this message shall be displayed to the current user or globally to all users with the corresponding permission. Defaults to user message.
 */
function commander_log( $message, $global=FALSE ) {
  
  if( !isset($message['timestamp']) )
    $message['timestamp'] = time();
  
  if( !isset($message['type']) )
    $message['type']      = 'notice';
  
  
  if( $global )
    $messages = variable_get( MODULE_COMMANDER_VARIABLE_MESSAGES, array() );
  else
    $messages = isset($_SESSION[ MODULE_COMMANDER_MESSAGES_SESSION_VARIABLE ]) ? $_SESSION[ MODULE_COMMANDER_MESSAGES_SESSION_VARIABLE ] : array();
  
  
  if( count($messages)==MODULE_COMMANDER_MAX_MESSAGES )
    array_shift( $messages );
  
  $i        = 0;
  while( $i<count($messages) && $messages[$i]['timestamp']<=$message['timestamp'] )
    $i++;
  
  array_splice( $messages, $i, 0, array($message) );
  
  
  if( $global )
    variable_set( MODULE_COMMANDER_VARIABLE_MESSAGES, $messages );
  else
    $_SESSION[ MODULE_COMMANDER_MESSAGES_SESSION_VARIABLE ] = $messages;
  
}

/**
 *  Get commander log messages
 *  
 *  @scope public
 *  @param global (boolean) Whether or not public messages shall be included. Defaults to permission check of the current user
 *  @return (array) All messages ordered by ascending timestamp
 */
function commander_get_log( $global=NULL ) {
  
  if( $global===NULL )
    $global = user_access( MODULE_COMMANDER_PERMISSION_VIEW_GLOBAL_LOG );
  
  $messages = isset($_SESSION[ MODULE_COMMANDER_MESSAGES_SESSION_VARIABLE ]) ? $_SESSION[ MODULE_COMMANDER_MESSAGES_SESSION_VARIABLE ] : array();
  
  if( $global ) {
    
    $global   = variable_get( MODULE_COMMANDER_VARIABLE_MESSAGES, array() );
    foreach( $global as $entry ) {
      
      $i  = 0;
      while( $i<count($messages) && $messages[$i]['timestamp']<$entry['timestamp'] )
        $i++;
      
      array_splice( $messages, $i, 0, array($entry) );
      
    }
    
  }
  
  if( count($messages)>MODULE_COMMANDER_MAX_MESSAGES )
    $messages = array_slice( $messages, count($messages) - MODULE_COMMANDER_MAX_MESSAGES );
  
  return $messages;
  
}


/**
 *  The heart of this module: Execute the given command in the given environment
 *  
 *  @scope public
 *  @param environment (array) The environment the command is executed in. Base can be gotten using commander_get_environment()
 *  @param input (string) The complete input string
 *  @return (bool) Whether or not the command was found, allowed to be executed and succeeded in executing
 */
function commander_execute( $environment, $input ) {
  
  // One central point to filter for users and their access rights
  $commands   = commander_get_commands( $environment['user'] );
  $types      = commander_get_argument_types();
  
  $name       = commander_get_command_name( $input );
  
  // Step I   Check that the command is known and the user is allowed to execute it
  if( !($command=_commander_get_by_name_or_alias($commands,$name)) ) {
    $commands   = commander_get_commands();
    if( ($command=_commander_get_by_name_or_alias($commands,$name)) ) {
      drupal_set_message( t('You\'re not allowed to execute %name!',array('%name'=>$name)), 'warning' );
    }
    else {
      drupal_set_message( t('Unknown command %name!',array('%name'=>$name)), 'warning' );
    }
    
    return FALSE;
  }
  
  $environment['command'] = $command;
  $environment['input']   = $input;
  
  // Step II  Parse given arguments
  module_load_include( 'php', 'commander', 'lib/morpol_cl_parser' );
  
  $arguments        = substr( $input, strlen($name)+1 );
  $flags            = _commander_get_command_parsing_flags( $command );
  if( isset($command['auto_argument']) )
    $flags            |= MORPOL_CommandLineParser::PF_ARGUMENTS_UNNAMED;
  
  $defaults         = commander_get_command_defaults( $environment, $command );
  $result           = MORPOL_CommandLineParser::parse( $arguments, $flags, $defaults, FALSE, '\\', NULL, MODULE_COMMANDER_UNNAMED_ARGUMENTS_INDEX );
  
  // Step III Commands may prepare the given arguments, if required
  if( isset($command['prepare']) ) {
    
    if( isset($command['file']) )
      module_load_include( '', $command['module'], $command['file'] );
    
    if( !$command['prepare']( $environment, $result ) ) {
      return FALSE;
    }
    
  }
  
  // Step IV  Auto add arguments to given default, if any
  if( isset($command['auto_argument']) && !count($result[ $command['auto_argument'] ]) )
    $result[ $command['auto_argument'] ]  = $result[ MODULE_COMMANDER_UNNAMED_ARGUMENTS_INDEX ];
  
  // Step V   Validate and prepare all given arguments
  $skip = array();
  foreach( $result as $name=>$values ) {
    
    if( in_array($name,$skip) )
      continue;
    
    // Step .I   Check that the argument is given (either by it's name or alias) for the case it is required
    $type     = NULL;
    $arg_def  = NULL;
    if( isset($command['arguments']) ) {
      $arg_def  = _commander_get_by_name_or_alias( $command['arguments'], $name );
      if( $arg_def ) {
        $type     = $arg_def['type'];
        if( isset($arg_def['required']) && $arg_def['required'] && !count($values) ) {
          
          if( isset($arg_def['alias']) && count($result[ $arg_def['alias'] ]) ) {
            $name   = $arg_def['alias'];
            $values = $result[ $name ];
          }
          else {
            drupal_set_message( t('%name is required!',array('%name'=>$name)) );
            
            return FALSE;
          }
          
        }
      }
      else
        $type     = 'string';
    }
    else {
      $type     = 'string';
    }
    
    $arg_name = isset($arg_def) && isset($arg_def['name']) ? $arg_def['name'] : $name;
    
    $type     = _commander_get_by_name_or_alias( $types, $type );
    
    // Step .II  Check that the argument fulfills the type's argc, if any
    if( $type['argc']>=0 && $type['argc']!=count($values) ) {
      if( isset($arg_def) && $arg_def['required'] ) {
        drupal_set_message( t('Argument %type requires %number arguments!',array('%type'=>$arg_name,'%number'=>$type['argc'])) );
        
        return FALSE;
      }
      else {
        $result[ $name ]  = array();
        
        continue;
      }
    }
    
    // Check that all include files are provided
    if( (isset($type['validate']) || isset($type['load'])) && isset($type['file']) ) {
      module_load_include( '', $type['module'], $type['file'] );
    }
    
    // Step .III Call validation function of argument type
    if( isset($type['validate']) ) {
      
      if( !$type['validate']( $environment, $values, $arg_def ) ) {
        drupal_set_message( t('Invalid %type %values for %name!',array('%type'=>$type['name'],'%values'=>implode(' | ',$values),'%name'=>$arg_name)) );
        
        return FALSE;
      }
      
    }
    
    // Step .IV  Load actual type's value from string
    if( isset($type['load']) ) {
      
      $result[ $name ]  = $type['load']( $environment, $values, $arg_def );
      
    }
    
    // Step .V   Save aliase's value as well and skip their validation (since the values will be the same)
    if( isset($arg_def) && isset($arg_def['alias']) ) {
      if( $name==$arg_def['alias'] ) {
        $result[ $arg_def['machine_name'] ] = $result[ $name ];
      }
      else {
        $result[ $arg_def['alias'] ]        = $result[ $name ];
      }
      
      $skip[] = $arg_def['alias'];
      $skip[] = $arg_def['machine_name'];
    }
    
  }
  
  // Include necessary files
  if( isset($command['file']) )
    module_load_include( '', $command['module'], $command['file'] );
  
  // Step VI  Validate command itself, if wanted
  if( isset($command['validate']) ) {
    
    if( !$command['validate']( $environment, $result ) ) {
      return FALSE;
    }
    
  }
  
  // Step VII Finally execute it!
  return $command['execute']( $environment, $result );
  
}

/**
 * Implements hook_init().
 */
function commander_init() {
  if( user_access( MODULE_COMMANDER_PERMISSION_ACCESS ) ) {
    /*drupal_add_library('system', 'jquery.form');
    drupal_add_library('system', 'drupal.ajax');*/
    
    drupal_add_js( 'misc/progress.js' );
    drupal_add_js( 'misc/ajax.js' );
    drupal_add_js( 'misc/autocomplete.js' );
    
    drupal_add_js( array( 'commander'=>array( 'environment'=>array( 'q'=>$_GET['q'] ) ) ), 'setting' );
    
    //$form = drupal_get_form( 'commander_execute_form' );
  }
}

/**
 *  Implements hook_exit
 */
function commander_exit() {
  
  if( isset($_SESSION['messages']) ) {
    
    foreach( $_SESSION['messages'] as $type=>$messages ) {
      
      foreach( $messages as $message ) {
        
        commander_log( array( 'message'=>$message, 'type'=>$type=='status'?'notice':$type, 'source'=>'message' ) );
        
      }
      
    }
    
  }
  
}

/**
 * Implements hook_permission().
 */
function commander_permission() {
  
  return array(
    
    MODULE_COMMANDER_PERMISSION_ACCESS          => array(
      'title'           => t('Access commander'),
      'description'     => t('Allow users to view the console and execute commands.'),
    ),
    
    MODULE_COMMANDER_PERMISSION_EXECUTE_ALL     => array(
      'title'           => t('Execute all commands'),
      'description'     => t('Allow users to execute any command. USE WITH CAUTION!'),
      'restrict access' => TRUE,
    ),
    
    MODULE_COMMANDER_PERMISSION_VIEW_GLOBAL_LOG => array(
      'title'           => t('View global log'),
      'description'     => t('Allow users to view the private site log. USE WITH CAUTION, THIS MAY CONTAIN SENSITIVE DATA!'),
      'restrict access' => TRUE,
    ),
    
  );
  
}

/**
 * Implements hook_menu().
 */
function commander_menu() {
  $items = array();
  
  $items['commander/ajax/console']      = array(
    'page callback'     => '_commander_console',
    'access callback'   => 'user_access',
    'access arguments'  => array(MODULE_COMMANDER_PERMISSION_ACCESS),
    'type'              => MENU_CALLBACK,
    'file'              => MODULE_COMMANDER_CLIENT_FILE,
  );
  
  $items['commander/ajax/execute']      = array(
    'page callback'     => '_commander_ajax_execute',
    'access callback'   => 'user_access',
    'access arguments'  => array(MODULE_COMMANDER_PERMISSION_ACCESS),
    'type'              => MENU_CALLBACK,
    'file'              => MODULE_COMMANDER_CLIENT_FILE,
  );
  
  $items['commander/ajax/autocomplete'] = array(
    'page callback'     => '_commander_autocomplete',
    'access callback'   => 'user_access',
    'access arguments'  => array(MODULE_COMMANDER_PERMISSION_ACCESS),
    'type'              => MENU_CALLBACK,
    'file'              => MODULE_COMMANDER_CLIENT_FILE,
  );
  
  return $items;
}

/**
 *  Implements hook_theme()
 */
function commander_theme( $existing, $type, $theme, $path ) {
  
  $items['commander_console_overlay'] = array(
    'variables' => array(
      'environment' => array(),
    ),
    'template'  => 'templates/commander-console-overlay',
  );
  
  $items['commander_execute_block'] = array(
    'variables' => array(
      'allow_fullscreen'  => FALSE,
      'messages'          => array(),
      'form'              => NULL,
    ),
    'template'  => 'templates/commander-execute-block',
  );
  
  $items['commander_log_entry']       = array(
    'variables' => array(
      'entry'     => array(),
    ),
    'template'  => 'templates/commander-log-entry',
  );
  
  return $items;
  
}

/**
 *  Implements hook_block_info()
 */
function commander_block_info() {
  
  $blocks           = array(
    
    'execute_command' => array(
      'info'            => t('Execute command'),
    ),
    
  );
  
  return $blocks;
  
}

/**
 *  Implements hook_block_view()
 */
function commander_block_view( $delta='' ) {
  
  $block  = array();
  
  if( $delta=='execute_command' ) {
    
    $block  = array(
      'subject' => t( 'Execute command' ),
      'content' => theme( 'commander_execute_block', array( 'allow_fullscreen'=>TRUE ) ),
    );
    
  }
  
  return $block;
  
}

/**
 * Implements hook_commander_command()
 */
function commander_commander_command() {
  
  $commands = array(
    
    'set-message'       => array(
      'description'       => t('Simply echo the given text'),
      'alias'             => 'echo',
      'access arguments'  => array( MODULE_COMMANDER_PERMISSION_ACCESS ),
      'execute'           => '_commander_execute_set_message',
      'file'              => MODULE_COMMANDER_EXECUTION_FILE,
      'type'              => COMMANDER_COMMAND_TYPE_UNNAMED_ARGUMENTS,
    ),
    
    'list-commands'     => array(
      'description'       => t('List all available commands'),
      'access arguments'  => array( MODULE_COMMANDER_PERMISSION_ACCESS ),
      'execute'           => '_commander_execute_list',
      'file'              => MODULE_COMMANDER_EXECUTION_FILE,
      'type'              => COMMANDER_COMMAND_TYPE_UNNAMED_ARGUMENTS,
    ),
    
    'alias-command'     => array(
      'description'       => t('Create an alias for another command (usually shortening something)'),
      'access arguments'  => array( MODULE_COMMANDER_PERMISSION_ACCESS ),
      'execute'           => '_commander_execute_alias',
      'file'              => MODULE_COMMANDER_EXECUTION_FILE,
      'type'              => COMMANDER_COMMAND_TYPE_UNNAMED_ARGUMENTS,
    ),
    
    'execute-commands'  => array(
      'description'       => t('Execute multiple commands at once'),
      'access arguments'  => array( MODULE_COMMANDER_PERMISSION_ACCESS ),
      'execute'           => '_commander_execute_execute',
      'file'              => MODULE_COMMANDER_EXECUTION_FILE,
      'type'              => COMMANDER_COMMAND_TYPE_UNNAMED_ARGUMENTS,
    ),
    
  );
  
  return $commands;
  
}

/**
 * Implements hook_commander_command_alter()
 */
function commander_commander_command_alter( &$commands ) {
  
  $aliases  = variable_get( MODULE_COMMANDER_VARIABLE_ALIASES, array() );
  foreach( $aliases as $name=>$alias ) {
    
    $command  = commander_get_command_name( $alias['command'] );
    if( !isset($commands[ $command ]) || isset($commands[ $name ]) )
      continue;
    
    $command  = $commands[ $command ];
    
    $commands[ $name ]  = array(
      'description'       => t('Alias for %command',array( '%command'=>$alias['command'] )),
      'access callback'   => isset($command['access callback']) ? $command['access callback'] : NULL,
      'access arguments'  => isset($command['access arguments']) ? $command['access arguments'] : NULL,
      'execute'           => '_commander_execute_alias_command',
      'file'              => MODULE_COMMANDER_EXECUTION_FILE,
    );
    
  }
  
}

/**
 *  Implements hook_commander_argument_type()
 */
function commander_commander_argument_type() {
  
  $types  = array(
    
    /*          BASE TYPES          */
    'bool'      => array(
      'name'      => 'Boolean',
      'alias'     => 'boolean',
      'validate'  => '_commander_validate_bool',
      'load'      => '_commander_load_bool',
      'list'      => NULL,
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
    ),
    
    'int'       => array(
      'name'      => 'Integer',
      'alias'     => 'integer',
      'validate'  => '_commander_validate_int',
      'load'      => '_commander_load_int',
      'list'      => NULL,
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
    ),
    
    'float'     => array(
      'name'      => 'Float',
      'alias'     => 'number',
      'validate'  => '_commander_validate_float',
      'load'      => '_commander_load_float',
      'list'      => NULL,
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
    ),
    
    'string'    => array(
      'name'      => 'String',
      'validate'  => NULL,
      'load'      => NULL,
      'list'      => NULL,
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
    ),
    
    /*          EXTENDED TYPES          */
    
    'datetime'  => array(
      'name'      => 'Datetime',
      'validate'  => '_commander_validate_datetime',
      'load'      => '_commander_load_datetime',
      'list'      => NULL,
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
      'defaults'  => array(
        'now'       => '_commander_default_datetime_now',
      ),
    ),
    
    /*            ENTITIES              */
    
    'user'      => array(
      'name'      => 'User',
      'validate'  => '_commander_validate_user',
      'load'      => '_commander_load_user',
      'list'      => '_commander_list_user',
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
      'defaults'  => array(
        'current_user'  => '_commander_default_user_current_user',
      ),
    ),
    
    'node'      => array(
      'name'      => 'Node',
      'validate'  => '_commander_validate_node',
      'load'      => '_commander_load_node',
      'list'      => '_commander_list_node',
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
      'defaults'  => array(
        'viewed_node'   => '_commander_default_node_viewed_node',
      ),
    ),
    
    'taxonomy_term' => array(
      'name'      => 'Taxonomy Term',
      'validate'  => '_commander_validate_term',
      'load'      => '_commander_load_term',
      'list'      => '_commander_list_term',
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
      'defaults'  => array(),
    ),
    
  );
  
  /*            FORM TYPES - WILL MOVE TO SEPARATE MODULE!        */
  /*$form_types = Array(
    'checkbox'          => 'Checkbox',
    'checkboxes'        => 'Checkboxes',
    'date'              => 'Date',
    'fieldset'          => 'Fieldset',
    'file'              => 'File',
    'machine_name'      => 'Machine Name',
    'managed_file'      => 'Managed File',
    'password'          => 'Password',
    'password_confirm'  => 'Password Confirm',
    'radio'             => 'Radio',
    'radios'            => 'Radios',
    'select'            => 'Select',
    'text_format'       => 'Text Format',
    'textarea'          => 'Textarea',
    'textfield'         => 'Textfield',
  );
  foreach( $form_types as $machine_name=>$name )
    $types[ 'form_'.$machine_name ] = array(
      'name'      => $name,
      'form_type' => $machine_name,
      'validate'  => '_commander_validate_form_element',
      'load'      => '_commander_load_form_element',
      'list'      => '_commander_list_form_element',
      'file'      => MODULE_COMMANDER_EXECUTION_FILE,
      'defaults'  => array(
        'form_value'  => '_commander_default_form_element_value',
      ),
    );*/
  
  return $types;
  
}

/**
 *  Implements hook_watchdog
 */
function commander_watchdog( $entry ) {
  
  static $type_map  = array();
  if( empty($type_map) ) {
    $type_map = array(
      WATCHDOG_EMERGENCY  => 'emergency',
      WATCHDOG_ALERT      => 'alert',
      WATCHDOG_CRITICAL   => 'critical',
      WATCHDOG_ERROR      => 'error',
      WATCHDOG_WARNING    => 'warning',
      WATCHDOG_NOTICE     => 'notice',
      WATCHDOG_INFO       => 'info',
      WATCHDOG_DEBUG      => 'debug',
    );
  }
  
  $item = array(
    'message'   => isset($entry['variables']) ? t( $entry['message'], $entry['variables'] ) : t( $entry['message'] ),
    'type'      => $type_map[ $entry[ 'severity' ] ],
    'timestamp' => $entry['timestamp'],
    'source'    =>'system',
  );
  
  commander_log( $item, TRUE );
  
}

/**
 *  Get the item with the given name/alias within the given list
 *  
 *  @scope private
 *  @param list (array) An associative array including items that are arrays, potentially including an 'alias' property
 *  @return (array) The item or NULL if it wasn't found
 */
function _commander_get_by_name_or_alias( &$list, $name ) {
  if( isset($list[$name]) )
    return $list[$name];
  
  foreach( $list as $item )
    if( isset($item['alias']) && $item['alias']==$name )
      return $item;
  
  return NULL;
}

/**
 *  Get a list of parsing flags passed to the MORPOL Command Line Parser
 *  
 *  @scope private
 *  @param command (array) The command definition to be used
 *  @return NULL
 */
function _commander_get_command_parsing_flags( $command ) {
  
  $flags  = MORPOL_CommandLineParser::PF_ARGUMENTS_DOUBLE_QUOTES | MORPOL_CommandLineParser::PF_ARGUMENTS_DOUBLE_QUOTES_ESCAPE;
  
  if( $command['type']==COMMANDER_COMMAND_TYPE_UNNAMED_ARGUMENTS )
    $flags  |= MORPOL_CommandLineParser::PF_ARGUMENTS_UNNAMED;
  elseif( $command['type']==COMMANDER_COMMAND_TYPE_SIGNED_ARGUMENTS )
    $flags  |= MORPOL_CommandLineParser::PF_ARGUMENTS_PLUS | MORPOL_CommandLineParser::PF_ARGUMENTS_MINUS;
  elseif( $command['type']==COMMANDER_COMMAND_TYPE_EQUAL_ARGUMENTS )
    $flags  |= MORPOL_CommandLineParser::PF_ARGUMENTS_EQUAL;
  
  return $flags;
  
}

/**
 *	Init the given command => Add module etc.
 *  
 *  @scope private
 *  @param types (array) A list of all argument types
 *	@param commands (array) A list of commands
 *	@param name (string) The name of the command within the list
 *  @param module (string) The module providing the command
 *	@return NULL
 */
function _commander_init_command( &$types, &$commands, $name, $module ) {
  
  $command  = &$commands[$name];
  
  $command['machine_name']  = $name;
  $command['module']        = $module;
  
  if( !isset($command['type']) )
    $command['type']          = COMMANDER_COMMAND_TYPE_DEFAULT;
  
  if( !isset($command['default']) && isset($command['default_value']) )
    $command['default']       = 'value';
  
  // Remove commands whose arguments use unknown types...
  if( isset($command['arguments']) ) {
    foreach( $command['arguments'] as $name=>$argument ) {
      
      if( !_commander_get_by_name_or_alias( $types, $argument['type'] ) ) {
        
        watchdog( 'commander', t('Command @name has been disabled for unknown argument type @type.'), array('@name'=>$name,'@type'=>$argument['type']), WATCHDOG_WARNING );
        unset( $commands[$name] );
        break;
        
      }
      
      $command['arguments'][$name]['machine_name']  = $name;
      
    }
  }
  
}


/**
 *  Define the execution form
 *  
 *  @scope private
 */
function commander_execute_form( $form, &$form_state, $id, $environment ) {
  
  $form['command']      = array(
    '#type'               => 'textfield',
    '#default_value'      => '',
    '#autocomplete_path'  => 'commander/ajax/autocomplete',
    '#maxlength'          => 65535,
    '#attributes'         => array(
      'id'                  => 'edit-command-'.str_replace( '_', '-', $id ),
    ),
  );
  
  $form['execute']      = array(
    '#type'               => 'submit',
    '#value'              => t('Execute'),
    '#ajax'               => array(
      'callback'            => 'commander_execute_form_callback',
      'wrapper'             => str_replace( '_', '-', $id ),
      //'name'                => $id.'1',
      'method'              => 'replace',
      'effect'              => 'fade',
    ),
    '#attributes'         => array(
      'id'                  => 'edit-execute-'.str_replace( '_', '-', $id ),
    ),
  );
  
  $form['#attributes']['id']  = str_replace( '_', '-', $id ).'-execute-form';
  
  $form_state['theme_id']     = $id;
  $form_state['environment']  = $environment;
  
  return $form;
  
}
function commander_execute_form_callback( $form, &$form_state ) {
  $display  = commander_execute_form_submit_handler( $form_state );
  
  $element            = array();
  $element['#markup'] = '';
  
  $function           = '_commander_theme_'.$form_state['theme_id'];
  $element['#markup'] .= $function( $display, $form );
  
  return $element;
}
function commander_execute_form_submit( $form, &$form_state ) {
  $display  = commander_execute_form_submit_handler( $form_state );
}
function commander_execute_form_submit_handler( &$form_state ) {
  
  $values   = $form_state['values'];
  $input    = $values['command'];
  
  $previous = drupal_set_message();
  
  drupal_set_message( t('> %input',array('%input'=>$input)) );
  
  $environment            = commander_get_environment( FALSE );
  
  foreach( $form_state['environment'] as $name=>$value ) {
    if( $name!='user' )
      $environment[$name] = $value;
  }
  
  $result = commander_execute( $environment, $input );
  $form_state['result'] = $result;
  
  $current  = drupal_set_message();
  $display  = array();
  
  foreach( $current as $type=>$messages ) {
    
    $removed  = 0;
    for( $i=0; $i<count($messages); $i++ ) {
      
      $message  = $messages[ $i ];
      
      if( !isset($previous[$type]) || !in_array( $message, $previous[$type] ) ) {
        
        $display[]  = array( 'timestamp'=>$environment['timestamp'], 'message'=>$message, 'type'=>$type=='status'?'notice':$type, 'source'=>'console' );
        array_splice( $_SESSION['messages'][$type], $i-$removed, 1 );
        $removed++;
        
      }
      
    }
    
    if( $removed==count($messages) )
      unset( $_SESSION['messages'][$type] );
    
  }
  
  foreach( $display as $message )
    commander_log( $message );
  
  return $display;
  
}
/**
 *  Simply return the form HTML
 *  
 *  @scope private
 */
function _commander_execute_form( $id, $environment=array() ) {
  $execute  = drupal_get_form( 'commander_execute_form', $id, $environment );
  
  return drupal_render( $execute );
}
/**
 *  Theme overlay
 *  
 *  @scope private
 */
function _commander_theme_commander_console_overlay( $messages=array(), $form=NULL ) {
  return theme( 'commander_console_overlay', array( 'messages'=>$messages, 'form'=>$form ) );
}
/**
 *  Theme block
 *  
 *  @scope private
 */
function _commander_theme_commander_execute_block( $messages=array(), $form=NULL ) {
  return theme( 'commander_execute_block', array( 'messages'=>$messages, 'form'=>$form ) );
}

/**
 *  Just get a static default value as defined in the argument definition
 *  Since this must be globally available, it's not stored in the separate exec-file
 *  
 *  @scope private
 */
function _commander_static_default_value( $environment, $arg_def ) {
  return $arg_def[ 'default_value' ];
}